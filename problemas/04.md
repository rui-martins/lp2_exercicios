# C# avançado e _design patterns_

1 - Considera a classe
[`ZipFile`](https://docs.microsoft.com/dotnet/api/system.io.compression.zipfile).
Que _design pattern_ pattern está a ser implementado por esta classe. Justifica
a tua resposta.

> [Soluções](../solucoes/04/001.md)

---

2 - Usando as interfaces nativas do C# para implementação do _Observer
pattern_, nomeadamente
[`IObserver<T>`](https://docs.microsoft.com/dotnet/api/system.iobserver-1) e
[`IObservable<T>`](https://docs.microsoft.com/dotnet/api/system.iobservable-1),
implementa:

1.  Um sujeito/observável que leia teclas do teclado (suprimindo a tecla lida
    de modo a que não apareça no ecrã) e notifique os observadores cada vez que
    uma tecla é premida.
2.  Um observador que indique no ecrã a tecla lida (e.g. `Detetada tecla
    'R'`).
3.  Um observador que guarde o carácter associado à tecla num ficheiro (em modo
    _append_).

O programa deve terminar quando for pressionada a tecla _Escape_.

> [Soluções](../solucoes/04/002.md)

---

3 - Resolve o exercício anterior com recurso a eventos.

> [Soluções](../solucoes/04/003.md)

---

4 - Cria os seguintes métodos de extensão para a classe
[`string`](https://docs.microsoft.com/dotnet/api/system.string):

1.  Método que conta o número de palavras numa _string_. Podes usar o método
[`Split()`](https://docs.microsoft.com/dotnet/api/system.string.split) para
dividir a _string_ em várias palavras, mas certifica-te que todos os caracteres
de _whitespace_ (i.e. espaços, tabs, _new lines_, etc) são usados como
separadores de palavras (estuda a documentação do método de modo para
perceberes como). Deves ainda ignorar palavras com comprimento zero.
2.  Método que conte o número de frases numa _string_. Podes assumir que uma
frase termina com um ponto final. Frases de comprimento zero ou só com
_whitespace_ não devem ser contadas.
3.  Método que conte o número de parágrafos numa _string_. Podes assumir que um
parágrafo termina com uma nova linha (carácter `\n`). Parágrafos com
comprimento zero ou só com _whitespace_ não devem ser contados.

Para testares os métodos, cria um programa que conte as palavras, frases e
parágrafos num ficheiro de texto, cujo nome deve ser passado como argumento na
linha de comandos. Neste programa deves apanhar e tratar todas as excepções que
possam ser lançadas pelo código de leitura do ficheiro.

> [Soluções](../solucoes/04/004.md)

---

5 - Cria um programa que apresente as seguintes estatísticas sobre um projeto
em C#:

1.  Número de linhas de código
2.  Número de linhas em branco (apenas _whitespace_)
3.  Número de linhas que são comentários (i.e. linhas que começam com `//`,
    ignorando comentários do estilo `/* ... */`)

Para o efeito deves criar três métodos de extensão apropriados com os nomes
`IsLineOfCode()`, `IsBlank()` e `IsComment()`, que devolvem um booleano
indicando se a linha (_string_) é do tipo em questão.

O programa deve receber como argumento da linha de comando uma pasta ou um
nome de ficheiro. Se for indicada uma pasta, o programa deve indicar a
estatística global para todos os ficheiros `.cs` na pasta e respetivas
sub-pastas. Caso seja indicado um ficheiro, o programa deve certificar-se que o
mesmo tem extensão `.cs` e mostrar as estatísticas apenas para esse ficheiro.

Este programa deve ser estruturado de acordo com as melhores práticas de
tratamento de exceções, design de classes e _design patterns_.

Apresenta também o diagrama UML simples (sem campos e métodos) da solução.

> [Soluções](../solucoes/04/005.md)

---

6 - Considera o
[exercício 7](https://github.com/VideojogosLusofona/lp2_2018_aulas/tree/master/Aula07/Exercicio7)
da
[aula 7](https://secure.grupolusofona.pt/ulht/moodle/mod/resource/view.php?id=158347).
Implementa um sistema de _achievements_ para o jogo. O sistema de _achivements_
deve ter as seguintes responsabilidades:

*   Conter uma referência para cada _achievement_ possível no jogo.
*   Cada uma dessas referências deve indicar se o respetivo _achievement_ já
    foi alcançado ou não, ou que percentagem ou partes do _achievement_ já
    foram completadas.
*   Registar um ou mais métodos em eventos pré-existentes que possam significar
    um _achievement_. No caso de eventos do tipo
    [`UnityEvent`](https://docs.unity3d.com/Manual/UnityEvents.html), o método
    ou métodos deve/devem ser registados de forma programática (no código) e
    não no editor. O método ou métodos em questão deve/devem verificar se o
    evento corresponde à completação parcial ou total de um _achievement_, e em
    caso afirmativo atualizar a respetiva referência ao mesmo.
*   Cada vez que um _achievement_ for alcançado, deve ser mostrada uma frase a
    verde na parte inferior da área de jogo, indicando o título do
    _achievement_ em questão e a percentagem de _achievements_ completados.

Inicialmente devem ser contemplados os seguintes  _achievements_:

*   **Gotcha** - Apanhar um alvo.
*   **Outlaw** - Ultrapassar o limite de velocidade.
*   **Persistent** - Apanhar 10 alvos.
*   **Bouncer** - Bater nas 4 paredes.

O sistema de _achievements_ deve ser implementado de acordo com as as melhores
práticas de design de classes e _design patterns_, tal que seja simples
adicionar mais _achievements_ posteriormente.

Apresenta também o diagrama UML simples (sem campos e métodos) da solução.

> [Soluções](../solucoes/04/006.md)

---

7 - Simplifica ao máximo a seguinte _struct_ usando lambdas e eventualmente
operadores ternários:

```cs
public struct GameMap
{
    private float topScore;
    private int gamesPlayed;
    private int gamesWon;

    public string Name { get; }
    public string Filename { get; }
    public float SuccessRate
    {
        get {
            if (gamesPlayed == 0)
                return 0f;
            else
                return gamesWon / (float) gamesPlayed;
        }
    }
    public float TopScore {
        get
        {
            return topScore;
        }
        set
        {
            if (value > topScore)
            {
                topScore = value;
            }
        }
    }

    public GameMap(string name, string filename)
    {
        Name = name;
        Filename = filename;
        gamesPlayed = 0;
        gamesWon = 0;
        topScore = 0;
    }

    public void GamePlayed(bool won)
    {
        gamesPlayed++;
        if (won)
        {
            gamesWon++;
        }
    }
}
```

> [Soluções](../solucoes/04/007.md)

---

8 - Simplifica ao máximo o seguinte código usando lambdas e eventualmente
operadores ternários:

```cs
public struct Bullet
{
    private float calibre;
    public float Calibre
    {
        get { return calibre; }
        set { if (value < 0.1f) calibre = 0.1f; else calibre = value; }
    }
}
```

```cs
public class Weapon
{
    public float Value { get; }
    public Weapon(float value) { Value = value; }
}
```

```cs
public class Gun : Weapon
{
    private Bullet[] bullets;
    public Gun(float value, int numBullets, float calibre) : base(value)
    {
        bullets = new Bullet[numBullets];
        for (int i = 0; i < numBullets; i++)
        {
            bullets[i] = new Bullet() { Calibre = calibre };
        }
    }
}
```

> [Soluções](../solucoes/04/008.md)

---

9 - Simplifica ao máximo o seguinte código usando lambdas e eventualmente
operadores ternários:

```cs
public struct Passenger
{
    private double weight;
    public double Weight
    {
        get { return weight; }
        set { if (value < 5) weight = 5; else weight = value; }
    }
}
```

```cs
public class Vehicle
{
    public double Value { get; }
    public Vehicle(double value) { Value = value; }
}
```

```cs
public class Car : Vehicle
{
    private Passenger[] passengers;
    public Car(double value, int numPassengers, float avgWeight) : base(value)
    {
        Random r = new Random();
        passengers = new Passenger[numPassengers];
        for (int i = 0; i < numPassengers; i++)
        {
            passengers[i] = new Passenger()
            {
                Weight = avgWeight + r.Next(-10, 10)
            };
        }
    }
}
```

> [Soluções](../solucoes/04/009.md)

---

10 - Considera a seguinte classe:

```cs
public static class VectorOperations
{
    // Normalized direction between two game objects
    public static Vector2 Direction(Vector2 from, Vector2 to)
    {
        return (to - from) / (to - from).magnitude;
    }

    // Distance between two game objects
    public static float Distance(Vector2 obj1, Vector2 obj2)
    {
        return (obj1 - obj2).magnitude;
    }

    // Convert angle in degrees into normalized vector
    public static Vector2 Deg2Vec(float angle)
    {
        float angleRad = angle * Mathf.Deg2Rad;
        return new Vector2(Mathf.Cos(angleRad), Mathf.Sin(angleRad));
    }

    // Determine angle of vector in degrees
    public static float Vec2Deg(Vector2 vector)
    {
        return Mathf.Atan2(vector.y, vector.x) * Mathf.Rad2Deg;
    }
}
```

Responde às seguintes questões:

1.  Simplifica os métodos usando lambas.
2.  Declara, para cada método, um _delegate_ personalizado compatível.
3.  Indica, para cada método, um _delegate_ pré-definido do C# que seja
    compatível.
4.  Assumindo que estás num método noutra classe, escreve quatro linhas de
    código nas quais declaras quatro variáveis do tipo _delegate_ pré-definido
    que indicaste na alínea anterior, atribuindo-lhes o respetivo método
    compatível.
5.  Repete a alínea anterior mas considerando os _delegates_ personalizados que
    declaraste na alínea 2 (e não os _delegates_ pré-definidos do C#).

> [Soluções](../solucoes/04/010.md)

---

11 - Considera o seguinte código:

```cs
public class EventProducer
{
    public string Str { get; private set; }
    public int N { get; private set; }

    protected virtual void OnProducedEvent()
    {
        ProducedEvent?.Invoke(Str, N);
    }
    public event Action<string, int> ProducedEvent;
}
```

O código anterior funciona perfeitamente, mas tens um patrão chato que exige
que uses _delegates_ propositadamente criados para uso em eventos. Assim sendo,
substitui o _delegate_ pré-definido
[`Action<T1,T2>`](https://docs.microsoft.com/dotnet/api/system.action-2)
pelo _delegate_ pré-definido
[`EventHandler<TEventArgs>`](https://docs.microsoft.com/dotnet/api/system.eventhandler-1),
alterando o código em conformidade. Poderá ser necessário criar uma classe
adicional.

> [Soluções](../solucoes/04/011.md)

---

12 - Compara a documentação dos _delegates_ pré-definidos
[`Action`](https://docs.microsoft.com/dotnet/api/system.action)
e
[`ThreadStart`](https://docs.microsoft.com/dotnet/api/system.threading.threadstart).
Porque razão não é possível utilizar o delegate `Action` em _threads_, tendo em
conta que ambos os _delegates_ devolvem `void` e não aceitam parâmetros.

> [Soluções](../solucoes/04/012.md)

---

13 - Qual é ou quais são as diferenças entre _delegates_ e eventos no C#?

> [Soluções](../solucoes/04/013.md)

---

14 - Que _design pattern_ é explicitamente implementado pelos eventos do C#?
Explica o teu raciocínio.

> [Soluções](../solucoes/04/014.md)

---

15 - O ficheiro [`015.tsv`](04/015.tsv) contém dados, separados por _tabs_,
sobre todos os exoplanetas conhecidos (a 30-11-2018). Cada linha contém a
seguinte informação:

*   ID do planeta
*   Nome do sistema estelar a que o planeta pertence
*   Letra do planeta dentro do seu sistema estelar
*   Nome do planeta
*   Método de deteção do planeta
*   Período orbital em dias
*   Distância em _parsecs_
*   Temperatura em Kelvins
*   Telescópio responsável pela descoberta

As linhas que começam com o carácter `#` são comentários e devem ser ignoradas.

Cria um projeto no Visual Studio que respeite os seguintes requisitos:

1.  Enumeração que contenha os diferentes métodos de descoberta de exoplanetas.
2.  _Struct_ imutável `Planet`, que contém toda a informação sobre um planeta
    sob a forma de propriedades só de leitura e um construtor para inicializar
    essas mesmas propriedades. Cada propriedade deve ser do tipo apropriado ao
    dado que reporta.
3.  A _struct_ `Planet` deve ter _overrides_ de `GetHashCode()` e `Equals()` de
    modo a que a igualdade entre planetas dependa apenas do respetivo ID.
4.  Classe `PlanetLoader`, com um único método `LoadPlanets()`. Este método
    aceita um parâmetro o nome de ficheiro que contém os dados sobre os
    planetas, devolvendo um `IEnumerable<Planet>` com todos os planetas lidos.
    Tanto a classe como o método devem ser `static`.
5.  Classe `Program`, com método `Main()`, no qual é invocado o método
    `LoadPlanets()`, e posteriormente mostrada no ecrã a seguinte informação,
    obtida com o uso de Lambdas e LINQ (sintaxe fluente ou expressões _query_,
    sem preferência):
    *   Número de exoplanetas existentes.
    *   Método mais comum de deteção.
    *   Máximo de exoplanetas em torno da mesma estrela.
    *   Média do período orbital.
    *   Planeta mais longíquo (e a respetiva distância).
    *   Média da temperatura dos planetas cuja estrela tem pelo menos dois
        planetas.
    *   Telescópio com menos descobertas.
6.  Todas as possíveis exceções devem ser tratadas ao nível da classe
    `Program`.
7.  Todas as classes e respetivos membros devem estar documentados com
    comentários XML.

> [Soluções](../solucoes/04/015.md)

---

16 - Desenha o diagrama UML completo do problema anterior (não requer resolução
     do problema).

> [Soluções](../solucoes/04/016.md)

---

17 - Considera o seguinte método:

```cs
public bool HasWeapons(int npcId)
{
    return npcs[npcId].Bag.Any(item => item.Category == ItemCategory.Weapon);
}
```

Responde às seguintes questões:

1.  Qual é a tua interpretação sobre o que o código está a fazer?
2.  Qual é o tipo da propriedade `Category`?
3.  Que princípio ou princípios de design estão a ser violados neste código?
    Que problemas poderão ocorrer se algum dos objetos manipulados for `null`?
4.  Simplifica o código usando operadores para tratamento de `null`s e
    expressões Lambda.

> [Soluções](../solucoes/04/017.md)

---

18 - O teu jogo é _shooter_ de sucesso, e a classe base de todas as armas é
`Weapon`, cuja interface está definida da seguinte forma:

```cs
interface IWeapon
{
    // This property is true if weapon is in alternate firing mode, false
    // otherwise
    bool IsAlternate { get; }

    // Reload the weapon
    void Reload();

    // Shoot the weapon, return true if any rounds left to shoot in current
    // firing mode, false otherwise
    bool Shoot();

    // Switch between main and alternate firing modes
    void SwitchFireMode();
}
```

Os teus investidores exigem um DLC que inclua _melee weapons_, ou seja, armas
para combate corpo a corpo. Os investidores tomaram a liberdade de adquirir um
pacote de _assets_ para esse fim, e querem integra-lo no jogo. A interface das
_melee weapons_ é a seguinte:

```cs
interface IMelee
{
    // Attacks return true if they hit opponent
    bool AttackFromAbove();
    bool AttackFromBelow();
    bool AttackFromTheLeft();
    bool AttackFromTheRight();
}
```

Como podes resolver este problema? Escreve código para esse fim e justifica as
tuas opções.

> [Soluções](../solucoes/04/018.md)

---

19 - Considera a seguinte enumeração:

```cs
public enum Quadrilateral { Square, Rectangle, Trapezoid, Rhombus, Kite }
```

Escreve um programa com duas _threads_. Uma das _threads_ coloca aleatoriamente
e com igual probabilidade itens desta enumeração numa pilha (_stack_)
_thread-safe_, com intervalos de colocação aleatórios entre 0 a 8 segundos. A
outra _thread_, que pode ser a _thread_ principal, retira todos os itens em
intervalos regulares de 10 segundos.

Após a colocação de um item, existe uma probabilidade de 5% da primeira
_thread_ decidir terminar o programa. Para o efeito, esta _thread_ coloca
`null` na pilha e finaliza a sua execução. A _thread_ principal, ao capturar
este `null` durante o desempilhamento, também finaliza a sua execução. Atenção
que as enumerações são tipos de valor e não aceitam diretamente o valor `null`.

A visualização do programa deve ser feita em modo de consola, com a consola
dividida em duas colunas:

1.  Os itens colocados na pilha pela primeira _thread_ são indicados na
    primeira coluna, até um máximo de 30 itens. Após a colocação de 30 itens,
    a coluna deve ser limpa e a indicação dos itens deve recomeçar no início da
    coluna.
2.  Quando a _thread_ principal retira os itens da pilha, deve indicar os itens
    retirados na segunda coluna. Antes de começar novo desempilhamento, a
    _thread_ deve limpar a coluna.

Este programa deve ser estruturado de acordo com as melhores práticas de
tratamento de exceções, design de classes e _design patterns_. Quaisquer
variáveis de tipos não _thread-safe_ partilhadas entre _threads_ devem estar
guardadas por _locks_.

> [Soluções](../solucoes/04/019.md)

---

20 - Implementa um jogo em modo consola, do estilo _Space Invaders_, no qual
o jogador controla uma defesa anti-aérea `^` que dispara um tiro `|` com
frequência máxima de um tiro por segundo. O tiro viaja à velocidade de 1
carácter de consola por cada 150 milisegundos. Deve também existir um alvo `O`,
que é destruído quando é atingido por um tiro, reaparecendo um novo alvo após 1
segundo.

O jogo deve ser implementado com as seguintes _threads_, que comunicam entre si
através de instâncias da fila _thread-safe_
[`BlockingCollection<T>`](https://docs.microsoft.com/dotnet/api/system.collections.concurrent.blockingcollection-1):

1.  A **_Thread_ de _input_** lê do teclado e envia as teclas lidas para uma
    fila _thread-safe_. São reconhecidas apenas as teclas _Espaço_, _Seta
    direita_, _Seta esquerda_ e _Escape_. As restantes teclas são ignoradas. A
    _thread_ deve terminar a sua execução quando detetar a tecla_Escape_,
    enviando a mesma para a fila antes de terminar.
2.  A **_Thread_ Jogador** controla o jogador `^`, obtendo as teclas da fila. O
    jogador pode andar para a esquerda e para a direita e disparar tiros `|`
    quando deteta a tecla _Espaço_. O jogador não pode disparar mais do que um
    tiro por segundo, devendo ignorar a tecla _Espaço_ durante esse período.
    Para disparar o tiro, a _thread_ Jogador lança uma nova _thread_ por cada
    tiro disparado, passando-lhe a posição atual do jogador. A _thread_ Jogador
    não tem de esperar (fazer _join_) das _threads_ de disparo, e termina
    quando detetar a tecla _Escape_ na fila _thread-safe_.
3.  Cada **_Thread_ de disparo** é responsável pela renderização e deteção de
    colisão de um tiro. Cada tiro sobe na vertical à velocidade de 1 caráter de
    consola por 150 milisegundos. Cada uma destas _threads_ termina quando o
    respetivo tiro desaparece do ecrã ou quando o mesmo colide com o alvo `O`.
    Neste último caso, antes de terminar, a _thread_ deve: a) retirar o alvo
    destruído do ecrã; b) esperar 1 segundo; e, c) colocar aleatoriamente um
    novo alvo no ecrã.

Este programa deve ser estruturado de acordo com as melhores práticas de
tratamento de exceções, design de classes e _design patterns_. Quaisquer
variáveis de tipos não _thread-safe_ partilhadas entre _threads_ devem estar
guardadas por _locks_.

> [Soluções](../solucoes/04/020.md)

---

21 - Cria uma _facade_ para o
[sistema de _input_ do Unity](https://docs.unity3d.com/ScriptReference/Input.html)
com um único método que devolve um
[`Vector2`](https://docs.unity3d.com/ScriptReference/Vector2.html). Esta
_facade_ deve contemplar _input_ de teclado, rato e controlador, e o `Vector2`
devolvido deve representar a direção do movimento num plano 2D.

Para testar a _facade_, cria uma _scene_ contendo um elemento
[`UI.Text`](https://docs.unity3d.com/ScriptReference/UI.Text.html) que mostre
o valor do vetor em cada momento

_Nota:_ A pasta do projeto Unity deve incluir este ficheiro
[`.gitignore`](https://github.com/VideojogosLusofona/lp2_2018_aulas/blob/master/Aula07/Exercicio7/.gitignore).

> [Soluções](../solucoes/04/021.md)

---

22 - Cria as seguintes classes:

*   Classe `AddManager`, com uma propriedade só de leitura de nome `Total` do
    tipo `int` (suportada numa variável de instância privada de nome `total`), e
    com um método `AddToTotal()`, que aceita um inteiro e adiciona-o à variável
    `total`. Esta classe deve ser um _singleton_ com inicialização _lazy_, e
    tanto a sua inicialização como a modificação da variável `total` (dentro do
    método `AddToTotal()`) devem ser _thread-safe_.
*   Classe `Adder`, com o método `LetsAdd()`, que cria e lança uma _thread_ que
    invoca 1000 vezes o método `AddToTotal()` da instância solitária de
    `AddManager`, passando-lhe inteiros aleatórios entre 0 e 100. A classe tem
    também a propriedade auto-implementada `Partial`, na qual a _thread_ guarda
    o total parcial relativo aos inteiros que somou. O método `LetsAdd()`
    retorna a instância da _thread_ criada e lançada.
*   Classe `Program`, com o método `Main()`, no qual: a) são criadas 20
    instâncias de `Adder`; b) é invocado o método `LetsAdd()` em cada delas,
    sendo mantidas referência às _threads_ devolvidas; c) é feita uma espera
    (com _join_) em todas as _threads_ devolvidas; d) é realizada e mostrada no
    ecrã a soma do `Partial` de todas as instâncias de `Adder`; e) é mostrado
    no ecrã o valor `Total` da instância solitária de `AddManager`; e, f) é
    indicado no ecrã se as somas são iguais ou não.

Nota que, para o programa estar correto, as somas devem ser sempre iguais.

> [Soluções](../solucoes/04/022.md)

---

23 - Desenha o diagrama UML completo do problema anterior (não é necessário
resolução do mesmo).

> [Soluções](../solucoes/04/023.md)

---

24 - Considera um jogo _tile-based_, em que cada _tile_ tem as seguintes
propriedades:

*   `DefensePoints` - Bónus de defesa (DEF)
*   `EssentialPoints` - Bónus de extração de bens essenciais (ESS)
*   `LuxuryPoints` - Bónus de extração de bens de luxo (LUX)

Inicialmente existem os seguintes tipos base de _tile_ com as características
indicadas:

*   _Grassland_: DEF = 0, ESS = 3, LUX = 0
*   _Desert_: DEF = -1, ESS = 0, LUX = 1
*   _Jungle_: DEF = 1, ESS = 1, LUX = 1
*   _Mountain_: DEF = 3, ESS = 1, LUX = 1

Além disso, estes _tiles_ pode ainda ter especializações particulares que podem
alterar as suas características conforme indicado:

*   _Vineyard_: ESS+1, LUX+1
*   _Sheep_: ESS+3
*   _Gold_: LUX+4
*   _Fortress_: DEF+3, LUX-1

Propõe uma solução para este problema, composta pelos seguintes elementos:

*   Diagrama UML completo.
*   Código C#, no qual se inclui uma classe `Program` para testar o código.

> [Soluções](../solucoes/04/024.md)

---

25 - Considera a seguinte classe C# para uso no Unity:

```cs
public class PlayerStats : MonoBehaviour {

    private Player player;

    private void Awake()
    {
        player = GameObject.FindWithTag("Player").GetComponent<Player>();
    }

    private void UpdatePowerUpStats(float powerUpMagnitude)
    {
        // Código que atualiza as estatísticas de power-ups do player
    }
}
```

Responde às seguintes questões:

1.  Indica um _delegate_ compatível com o método `UpdatePowerUpStats`.
2.  Considera que a classe `Player` tem um evento nativo do C# chamado
    `PickedUpAPowerUp`. Completa a classe `PlayerStats` de modo a que o método `UpdatePowerUpStats` seja notificado desse evento quando a instância de
    `Player` estiver ativa.
3.  Responde à questão anterior considerando que o `PickedUpAPowerUp` é do tipo
    `UnityEvent<float>`.

> [Soluções](../solucoes/04/025.md)

---

26 - Descreve, por palavras tuas, três dos principais problemas no uso de
_singletons_. Qual é a principal vantagem no uso deste _design pattern_?

> [Soluções](../solucoes/04/026.md)

---

27 -  Considera a seguinte enumeração:

```cs
enum Monster { Troll, Ogre, Elf, Demon, Vampire, Werewolf, Minion }
```

Responde às seguintes questões:

1.  Declara uma lista de `Monster` na qual seja possível também introduzir
    `nulls`.
2.  Assume que a variável `monst` é do tipo `Monster`. Escreve uma linha de
    código onde atribuis à variável `monst` o valor do primeiro elemento da
    lista da alínea anterior, tendo em conta que se este valor for `null`, o
    valor efetivamente a atribuir será `Minion`.
3.  Escreve o código de um método que receba a lista da primeira alínea e
    devolva um inteiro indicando quantos `nulls` existem na lista. O método
    deve ser o mais compacto possível, fazendo uso Lambdas e LINQ.

> [Soluções](../solucoes/04/027.md)

---
